# 操作系统课程设计

[ 2020302111244 ]

赵星宇



## Ch 1 & Ch 2

第一章要求实现一个最小的、在主机上能运行的磁盘引导程序。程序不断循环“打印`Hello, OS World`”函数，编译后写入软盘中，将前`512`字节剩余的部分用`0`填充，并在末尾写入`0xaa55`，从而使得软盘分区被识别为可引导。正常运行后，在屏幕上打印出红色的`Hello, OS World`。

第二章主要内容包括搭建`Windows`系统下的开发环境和`Linux`系统下的开发环境。两个操作系统下均可使用`bochs`模拟器或者`qemu`来运行。`qemu`可以启用`kvm`来进行加速。此外，常用商业化虚拟机软件`VMWare`在这些实验中也能够得到使用。

## Ch 3

书本从第三章开始，进入到保护模式与实模式的讲解。前两节分析了保护模式的特点，第一节说明了如何从实模式进入保护模式，第二节讲述了如何从保护模式返回到实模式，介绍了特权级的转移以及调用门的使用，并进行了“保护模式下具有更大的寻址空间”的验证。第三节主要分析了分页机制，第四章主要分析了中断和异常机制。第五章简短地介绍了保护模式下的`I/O`.

### 保护模式

 保护模式是`IA32`下CPU的两种工作模式之一，另一种方式为向前兼容的实模式。

在保护模式下，有一个特殊的“段”叫做`GDT`，其基址保存在`GDTR`寄存器中。`GDT`即全局描述表，表中包含：一个段的基地址，段界限，以及该段的属性。基地址即起始地址，段界限即长度，属性包含多个方面，如P位代表是否存在于内存中，DPL位标识该段的特权级别，TYPE表示描述符类型等。

`GDT`实际上是一个这样的段：它“存储其他各个段的信息”。因此有了这一机制，我们可以通过查询`GDT`来较为容易地跳转到其他各个段中。又因为`GDT`中描述了段的属性，因此可以做到禁止某一些段对另一些段的访问，因此有了特权级，有了数据保护的作用，这为多任务的开展打下了良好的基础。

### 从实模式跳转到保护模式

#### 初始化 GDT

首先，保护模式需要有一个内容完备的`GDT`。因此第一步，需要将`DGT`进行初始化。(该步骤主要分析代码`ch3/a/pmtest1.asm`)

书中代码中，在`SECTION .gdt`中，首先确定了`GDT`的大致格式，留下一个框架。

![image-20220703161653271](/home/z/.config/Typora/typora-user-images/image-20220703161653271.png)

但是其中的数据并非完全正确，例如`LABEL_DESC_CODE`的段基址显然是错误的。

`GdtLen`和`GdtPtr`的意义在代码注释中已经说明，`GDT`选择子的意义可以从其数值计算过程看出，是`GDT`的每个段的首地址相对于`GDT`基地址的偏移量。

实际上，`GDT`可以在内存中任意位置，但该代码中为了保证足够简单从而方便读者阅读，选择基地址为 0。

程序中，首先执行的是`[SECTION .s16]`中的代码。可以看到，在设置好段寄存器后，程序开始正常运行，而这之后一开始的步骤便是进行`GDT`的初始化。![image-20220703162730058](/home/z/.config/Typora/typora-user-images/image-20220703162730058.png)

这里将`LABEL_SEG_CODE32`在内存中的实际地址放进`eax`寄存器，然后将其中的信息分门别类地放入`GDT`对应段的表项中，从而`GDT`获得了正确的值，完成了初始化。

#### 用`lgdt`命令加载`GDTR`寄存器

该过程在如下代码中体现

![image-20220703163256781](/home/z/.config/Typora/typora-user-images/image-20220703163256781.png)

首先是设置了`GdtPtr`（严格意义上来说，设置GdtPtr这一行为也算是在“初始化GDT”，只是初始化的内容并非表项），然后将`GdtPtr`中的内容（即`GDT`）的基地址放进`GDTR`中。

#### 关中断和打开A20地址线

随后，由于实模式和保护模式下的中断处理机制是不一样的，需要关闭中断。由于保护模式下，可以访问超过1M的地址，为防止出错，需要开启A20地址线。

#### 设置`cr0`寄存器的`PE`位

 该位即代表机器所处的模式。当这一位设置好之后，系统就已经运行在保护模式之下了，但此时`cs`的值仍然是实模式下的值。

#### 特殊`jmp`

`jmp  dword SelectorCode32:0`

该指令会把 `SelectorCode32`装入`cs`，并跳转到`Code32Selector:0`处。

至此，系统已经进入保护模式，并开始运行保护模式下的代码。

> 注：pmtest1.asm 代码，如果直接编译成 bin 文件并写入磁盘镜像来裸机运行，会出现引导失败的报错。其原因在于其前512字节末尾没有写入`0xaa55`
>
> 正确使用方法应该是将其编译为 .com 文件，然后在 freedos 的环境下作为应用程序运行。

### 从保护模式回到实模式

从保护模式回到实模式的过程中，大致是从实模式跳转到保护模式的逆过程，即先跳转，然后恢复各个段寄存器的值，恢复栈指针，然后关闭A20地址线，最后打开中断。这样就能够回到实模式。

但是在执行`jmp`指令之前，需要先加载一个合适的描述符选择子到有关段寄存器。其原因在于，跳转后所执行的代码段是16位代码段，但是保护模式下段寄存器中的属性可能不符合实模式的要求，且由于实模式下无法修改段界限和段属性等，需要在保护模式下先进行修改，从而使得实模式下能够正常工作。

![image-20220703170230179](/home/z/.config/Typora/typora-user-images/image-20220703170230179.png)

在执行完`pmtest2.com`后，系统重新出现 dos 提示符，说明回到了实模式下。

（个人对代码进行了些许修改，实验现象略有不同，但是性质一致）



### 特权级



​                                                                                               